<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HealthHelp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Leaflet Control Layers Tree (for togglable layers) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/dist/Leaflet.Control.Layers.Tree.css" />
  <!-- Leaflet-Geoman for drawing/uploading -->
  <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css"/>
  <!-- Leaflet Timeline for storyboard -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-timeline/dist/leaflet-timeline.min.css"/>
  <style>
    body, html {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      background: #380000;
      color: #fff;
    }
    #header {
      background: linear-gradient(90deg, #8B0000 75%, #380000 100%);
      padding: 12px 24px;
      display: flex;
      align-items: center;
      box-shadow: 0px 2px 12px #222;
    }
    #logo {
      height: 48px;
      margin-right: 18px;
      border-radius: 12px;
      box-shadow: 0 0 8px #fff4;
      background: #fff;
      object-fit: contain;
    }
    #title {
      font-size: 2rem;
      font-weight: bold;
      letter-spacing: 2px;
      color: #fff;
      text-shadow: 0 2px 8px #600;
    }
    #map {
      width: 100vw;
      height: calc(100vh - 72px);
      z-index: 1;
      position: relative;
    }
    #sidebar {
      position: absolute;
      top: 20px;
      right: 24px;
      z-index: 1000;
      background: rgba(56,0,0,0.95);
      color: #fff;
      padding: 22px 18px 12px 18px;
      border-radius: 18px;
      box-shadow: 0 4px 24px #980000bb;
      max-width: 340px;
      min-width: 280px;
      font-size: 1rem;
    }
    .section-title {
      color: #fff;
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 8px;
      border-bottom: 1px solid #980000;
      padding-bottom: 4px;
    }
    .upload-group {
      margin-bottom: 18px;
    }
    .upload-group label {
      font-size: 0.95em;
      margin-bottom: 4px;
      display: block;
    }
    .upload-group input {
      margin-bottom: 8px;
      width: 100%;
    }
    #layer-controls, #storyboard-controls {
      margin-bottom: 18px;
    }
    #storyboard-year {
      width: 100%;
      margin-bottom: 8px;
    }
    .basemap-btn {
      display: block;
      margin-bottom: 7px;
      background: #600;
      color: #fff;
      border: none;
      border-radius: 7px;
      padding: 6px 9px;
      font-size: 0.93em;
      cursor: pointer;
      box-shadow: 0 2px 8px #400;
      transition: background .15s;
    }
    .basemap-btn.selected, .basemap-btn:hover {
      background: #C81E1E;
    }
    .attribute-popup {
      min-width: 220px;
      font-size: 1em;
      color: #222;
    }
    ::selection {
      background: #C81E1E;
      color: #fff;
    }
    @media (max-width: 900px) {
      #sidebar {
        max-width: 98vw;
        min-width: 40vw;
        right: 2vw;
        top: 10vw;
      }
    }
  </style>
</head>
<body>
  <div id="header">
    <img id="logo" src="HealthHelpLogo.png" alt="HealthHelp Logo">
    <div id="title">HealthHelp geoAI</div>
  </div>
  <div id="map"></div>
  <div id="sidebar">
    <div class="section-title">Layer Controls</div>
    <div id="layer-controls"></div>
    <div class="section-title">Thematic Storyboard</div>
    <div id="storyboard-controls">
      <label for="storyboard-year">Year:</label>
      <input type="range" id="storyboard-year" min="2010" max="2025" value="2025" step="1" />
      <span id="storyboard-year-value">2025</span>
      <select id="story-layer-select">
        <option value="maternal">Maternal/Newborn/Child Death Rate</option>
        <option value="hiv">HIV/AIDS-related Death Rate</option>
        <option value="facilities">Health Facilities Count</option>
        <option value="poverty-maternal">High Poverty+Population+Maternal/Newborn/Child Death Rate</option>
        <option value="poverty-hiv">High Poverty+Population+HIV/AIDS-related Death Rate</option>
      </select>
    </div>
    <div class="section-title">Basemap</div>
    <div id="basemap-controls">
      <!-- Basemap buttons will be injected -->
    </div>
    <div class="section-title">Upload/Analyze</div>
    <div class="upload-group">
      <label for="upload-shapefile">Upload Shapefile (.zip):</label>
      <input type="file" id="upload-shapefile" accept=".zip">
      <label for="upload-geojson">Upload GeoJSON:</label>
      <input type="file" id="upload-geojson" accept=".geojson,application/json">
      <label for="upload-other">Upload Other Geospatial Files:</label>
      <input type="file" id="upload-other" accept=".kml,.gpx,.csv">
      <button class="basemap-btn" id="save-data-btn">Save Data Locally</button>
    </div>
    <div>
      <small style="color:#e8a;">Click anywhere on the map to show attributes.</small>
    </div>
  </div>
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Leaflet Control Layers Tree -->
  <script src="https://unpkg.com/leaflet.control.layers.tree/dist/Leaflet.Control.Layers.Tree.js"></script>
  <!-- Leaflet-Geoman for draw/upload -->
  <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.min.js"></script>
  <!-- leaflet-timeline -->
  <script src="https://unpkg.com/leaflet-timeline/dist/leaflet-timeline.min.js"></script>
  <!-- shp.js for reading zipped shapefiles -->
  <script src="https://unpkg.com/shpjs/dist/shp.min.js"></script>
  <!-- toGeoJSON for KML/GPX -->
  <script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.min.js"></script>
  <!-- JSZip for zip file handling -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- geoAI functions placeholder -->
  <script>
    // Map Initialization
    const philippinesBounds = [[4.5, 116.8], [21.0, 127.0]];
    const map = L.map('map', {
      center: [12.8797, 121.7740],
      zoom: 6,
      minZoom: 5,
      maxZoom: 16,
      maxBounds: philippinesBounds,
      attributionControl: false,
      zoomControl: true,
      preferCanvas: true
    });

    // Basemap Layers (Open Source only)
    const basemaps = {
      "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {id:'osm', attribution:'&copy; OpenStreetMap contributors'}),
      "Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {id:'satellite', attribution:'&copy; ESRI, Maxar'}),
      "Satellite+Labels": L.layerGroup([
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {id:'satellite', attribution:''}),
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {id:'labels', opacity: 0.5, attribution:''})
      ]),
      "Dark": L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_dark/{z}/{x}/{y}{r}.png', {id:'dark', attribution:'&copy; Stadia Maps'}),
      "Terrain": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {id:'terrain', attribution:'&copy; OpenTopoMap'}),
      "CartoDB Positron": L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {id:'carto', attribution:'&copy; CartoDB'})
    };
    basemaps["OpenStreetMap"].addTo(map);

    // Basemap Controls
    const basemapControlDiv = document.getElementById("basemap-controls");
    Object.keys(basemaps).forEach((bm, i) => {
      const btn = document.createElement("button");
      btn.innerText = bm;
      btn.className = "basemap-btn" + (i===0 ? " selected" : "");
      btn.onclick = () => {
        Object.values(basemaps).forEach(l => map.removeLayer(l));
        Object.keys(basemaps).forEach(k => {
          basemapControlDiv.querySelectorAll(".basemap-btn")[i].classList.remove("selected");
        });
        btn.classList.add("selected");
        basemaps[bm].addTo(map);
      };
      basemapControlDiv.appendChild(btn);
    });

    // GeoAI Functions Placeholder
    const geoAI = {
      // Analyze, visualize, extract features, etc.
      analyze: (data) => {
        // Placeholder for advanced geoAI analysis
        alert("geoAI: Analysis placeholder for uploaded data.");
      },
      visualize: (data) => {
        // Placeholder for advanced geoAI visualization
        alert("geoAI: Visualization placeholder for uploaded data.");
      }
    };

    // Boundary Layers - Placeholder URLs, replace with actual sources
    const boundaryURLs = {
      region: 'https://raw.githubusercontent.com/HealthHelps/geoAI/main/data/philippines_regions.geojson',
      province: 'https://raw.githubusercontent.com/HealthHelps/geoAI/main/data/philippines_provinces.geojson',
      municipality: 'https://raw.githubusercontent.com/HealthHelps/geoAI/main/data/philippines_municipalities.geojson',
      barangay: 'https://raw.githubusercontent.com/HealthHelps/geoAI/main/data/philippines_barangays.geojson'
    };
    const boundaryLayers = {};
    function styleBoundary(level) {
      const colors = {
        region: "#ad1d1d",
        province: "#d45e5e",
        municipality: "#ffb0b0",
        barangay: "#fbdcdc"
      };
      return {
        color: colors[level] || "#ad1d1d",
        fill: false,
        weight: level==='barangay'? 0.5 : (level==='municipality'? 1 : (level==='province'? 1.3 : 2)),
        opacity: 0.8
      };
    }
    function addBoundaryLayer(level, url) {
      fetch(url)
        .then(res => res.json())
        .then(geojson => {
          boundaryLayers[level] = L.geoJson(geojson, {
            style: styleBoundary(level),
            onEachFeature: onEachFeature
          });
        });
    }
    Object.entries(boundaryURLs).forEach(([level, url]) => addBoundaryLayer(level, url));

    // Layer Controls (toggle)
    function updateLayerControls() {
      const layerDiv = document.getElementById("layer-controls");
      layerDiv.innerHTML = '';
      Object.keys(boundaryLayers).forEach(level => {
        const check = document.createElement("input");
        check.type = "checkbox";
        check.id = `layer-${level}`;
        check.checked = false;
        check.onchange = (e) => {
          if (e.target.checked) map.addLayer(boundaryLayers[level]);
          else map.removeLayer(boundaryLayers[level]);
        };
        const lbl = document.createElement("label");
        lbl.htmlFor = check.id;
        lbl.innerText = level.charAt(0).toUpperCase() + level.slice(1);
        layerDiv.appendChild(check);
        layerDiv.appendChild(lbl);
        layerDiv.appendChild(document.createElement("br"));
      });
    }
    // Wait for layers to load
    setTimeout(updateLayerControls, 2000);

    // Thematic Layer Data (fake demo data structure, replace with real data)
    let thematicData = {
      maternal: {}, hiv: {}, facilities: {}, "poverty-maternal": {}, "poverty-hiv": {}
    };
    // Load demo thematic polygons
    function loadThematicData() {
      // For demo, just load region-level polygons and random values for each year (2010-2025)
      fetch(boundaryURLs.region)
        .then(res => res.json())
        .then(geojson => {
          for (let type of Object.keys(thematicData)) {
            thematicData[type] = {};
            for (let year=2010; year<=2025; year++) {
              thematicData[type][year] = L.geoJson(geojson, {
                style: feature => {
                  const val = Math.random();
                  let fill;
                  if (type==='maternal') fill = `rgba(200,30,30,${0.4+val*0.5})`;
                  else if (type==='hiv') fill = `rgba(221,0,97,${0.4+val*0.5})`;
                  else if (type==='facilities') fill = `rgba(92,0,32,${0.4+val*0.5})`;
                  else fill = `rgba(130,0,0,${0.4+val*0.5})`;
                  return {fillColor: fill, color: "#980000", weight: 1, fillOpacity: 0.45+val*0.35};
                },
                onEachFeature: onEachFeature
              });
            }
          }
        });
    }
    loadThematicData();

    // Health Facilities Points (demo only)
    let healthFacilities = L.layerGroup();
    function loadDemoFacilities() {
      // Demo: random points, replace with actual source
      let demoData = [
        {name:"RHUs Manila", type:"RHU", lat:14.6, lng:120.98, services:["MNCH","FP","HIV/AIDS"], ownership:"public"},
        {name:"PHU Pampanga", type:"PHU", lat:15.05, lng:120.69, services:["MNCH"], ownership:"public"},
        {name:"BHC Cebu", type:"BHC", lat:10.31, lng:123.89, services:["MNCH","FP"], ownership:"public"},
        {name:"Lying-In Clinic Makati", type:"Clinic", lat:14.55, lng:121.02, services:["MNCH","FP"], ownership:"private"}
      ];
      demoData.forEach(f => {
        let marker = L.circleMarker([f.lat, f.lng], {
          color: f.ownership==='public'? "#e13c3c":"#980000",
          radius: 9,
          fillOpacity: 0.85
        }).bindPopup(`
          <div class="attribute-popup">
            <b>${f.name}</b><br>
            Type: ${f.type}<br>
            Services: ${f.services.join(", ")}<br>
            Ownership: ${f.ownership}
          </div>
        `);
        healthFacilities.addLayer(marker);
      });
    }
    loadDemoFacilities();
    healthFacilities.addTo(map);

    // Storyboard Controls
    let activeStoryLayer = "maternal";
    let activeYear = 2025;
    let thematicLayer = null;
    function updateStoryboard() {
      // Remove current thematic layer
      if (thematicLayer) map.removeLayer(thematicLayer);
      // Add layer for selected story and year
      thematicLayer = thematicData[activeStoryLayer] && thematicData[activeStoryLayer][activeYear];
      if (thematicLayer) thematicLayer.addTo(map);
    }
    document.getElementById("storyboard-year").oninput = function(e){
      activeYear = parseInt(e.target.value);
      document.getElementById("storyboard-year-value").innerText = activeYear;
      updateStoryboard();
    };
    document.getElementById("story-layer-select").onchange = function(e){
      activeStoryLayer = e.target.value;
      updateStoryboard();
    };
    setTimeout(updateStoryboard, 2500);

    // Upload/Save Functions
    function handleFileUpload(file, type) {
      if (type === "shapefile") {
        // Unzip and render as GeoJSON
        shp(file).then(function(geojson){
          const lyr = L.geoJson(geojson, {
            style: {color: "#ad1d1d", fillColor: "#d45e5e", fillOpacity: 0.45},
            onEachFeature: onEachFeature
          });
          lyr.addTo(map);
          geoAI.analyze(geojson);
        });
      } else if (type === "geojson") {
        const reader = new FileReader();
        reader.onload = function(e){
          const geojson = JSON.parse(e.target.result);
          const lyr = L.geoJson(geojson, {
            style: {color: "#ad1d1d", fillColor: "#d45e5e", fillOpacity: 0.45},
            onEachFeature: onEachFeature
          });
          lyr.addTo(map);
          geoAI.analyze(geojson);
        };
        reader.readAsText(file);
      } else {
        // KML/GPX/other to GeoJSON
        const reader = new FileReader();
        reader.onload = function(e){
          let geojson;
          if (file.name.endsWith('.kml')) {
            const parser = new DOMParser();
            const kml = parser.parseFromString(e.target.result, 'text/xml');
            geojson = toGeoJSON.kml(kml);
          } else if (file.name.endsWith('.gpx')) {
            const parser = new DOMParser();
            const gpx = parser.parseFromString(e.target.result, 'text/xml');
            geojson = toGeoJSON.gpx(gpx);
          } else if (file.name.endsWith('.csv')) {
            // Very basic CSV to geojson: expects lat,lng columns
            geojson = {type:"FeatureCollection",features:[]};
            const lines = e.target.result.split('\n');
            for (let line of lines.slice(1)) {
              const vals = line.split(',');
              if (vals.length<2) continue;
              geojson.features.push({
                type:"Feature",
                geometry:{type:"Point",coordinates:[parseFloat(vals[1]),parseFloat(vals[0])]},
                properties:{}
              });
            }
          }
          if (geojson) {
            const lyr = L.geoJson(geojson, {
              style: {color: "#ad1d1d", fillColor: "#d45e5e", fillOpacity: 0.45},
              onEachFeature: onEachFeature
            });
            lyr.addTo(map);
            geoAI.analyze(geojson);
          }
        };
        reader.readAsText(file);
      }
    }
    document.getElementById("upload-shapefile").onchange = function(e){
      if (e.target.files.length) handleFileUpload(e.target.files[0], "shapefile");
    };
    document.getElementById("upload-geojson").onchange = function(e){
      if (e.target.files.length) handleFileUpload(e.target.files[0], "geojson");
    };
    document.getElementById("upload-other").onchange = function(e){
      if (e.target.files.length) handleFileUpload(e.target.files[0], "other");
    };
    document.getElementById("save-data-btn").onclick = function(){
      alert("Local data saving is only available in modern browsers. Data will be downloaded as GeoJSON.");
      // Collect all visible layers and download as geojson
      let allFeatures = [];
      map.eachLayer(layer => {
        if (layer.toGeoJSON) {
          try {
            const geojson = layer.toGeoJSON();
            if (geojson.features) allFeatures = allFeatures.concat(geojson.features);
          } catch(e){}
        }
      });
      const blob = new Blob([JSON.stringify({type:'FeatureCollection',features:allFeatures})], {type: "application/json"});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "healthhelp_data.geojson";
      a.click();
    };

    // Show attributes popup on click
    function onEachFeature(feature, layer) {
      layer.on('click', function (e) {
        let props = feature.properties || {};
        let html = '<div class="attribute-popup"><b>Attributes:</b><br>';
        for (let k in props) {
          html += `<span style="color:#980000">${k}</span>: ${props[k]}<br>`;
        }
        html += '</div>';
        layer.bindPopup(html).openPopup();
      });
    }
    map.on('click', function(e){
      // Show lat/lng popup
      L.popup()
        .setLatLng(e.latlng)
        .setContent(`<div class="attribute-popup"><b>Coordinates:</b><br>Lat: ${e.latlng.lat.toFixed(6)}<br>Lng: ${e.latlng.lng.toFixed(6)}</div>`)
        .openOn(map);
    });

    // Leaflet-Geoman Controls (draw/upload)
    map.pm.addControls({
      position: 'topleft',
      drawMarker: true,
      drawPolygon: true,
      drawPolyline: true,
      drawCircle: true,
      drawRectangle: true,
      drawCircleMarker: true,
      editMode: true,
      dragMode: true,
      cutPolygon: true,
      removalMode: true,
      rotateMode: false
    });
    map.on('pm:create', e => {
      geoAI.visualize(e.layer.toGeoJSON());
      e.layer.bindPopup('<b>Custom Geometry</b>').openPopup();
    });

    // Add scale
    L.control.scale({position:'bottomleft'}).addTo(map);

    // Add attribution
    L.control.attribution({position:'bottomright'}).addAttribution('HealthHelp geoAI &copy; 2025 | <a href="https://github.com/HealthHelps/geoAI" style="color:#e8a;">Source</a>');

    // Responsive sidebar
    window.onresize = () => {
      document.getElementById("map").style.height = (window.innerHeight - document.getElementById("header").offsetHeight) + "px";
    };
    window.dispatchEvent(new Event('resize'));
  </script>
</body>
</html>
